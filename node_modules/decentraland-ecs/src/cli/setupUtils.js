"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.createStaticRoutes = exports.getDirectories = exports.defaultDclIgnore = exports.shaHashMaker = exports.downloadFile = exports.ensureCopyFile = exports.ensureWriteFile = exports.getSceneJson = exports.entityV3FromFolder = exports.getFilesFromFolder = exports.defaultHashMaker = exports.copyDir = void 0;
var fs = require("fs");
var glob_1 = require("glob");
var path = require("path");
var http = require("http");
var https = require("https");
var crypto = require("crypto");
var ignore_1 = require("ignore");
var schemas_1 = require("@dcl/schemas");
// instead of using fs-extra, create a custom function to no need to rollup
function copyDir(src, dest) {
    return __awaiter(this, void 0, void 0, function () {
        var entries, _i, entries_1, entry, srcPath, destPath, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, fs.promises.mkdir(dest, { recursive: true })];
                case 1:
                    _b.sent();
                    return [4 /*yield*/, fs.promises.readdir(src, { withFileTypes: true })];
                case 2:
                    entries = _b.sent();
                    _i = 0, entries_1 = entries;
                    _b.label = 3;
                case 3:
                    if (!(_i < entries_1.length)) return [3 /*break*/, 9];
                    entry = entries_1[_i];
                    srcPath = path.join(src, entry.name);
                    destPath = path.join(dest, entry.name);
                    if (!entry.isDirectory()) return [3 /*break*/, 5];
                    return [4 /*yield*/, copyDir(srcPath, destPath)];
                case 4:
                    _a = _b.sent();
                    return [3 /*break*/, 7];
                case 5: return [4 /*yield*/, fs.promises.copyFile(srcPath, destPath)];
                case 6:
                    _a = _b.sent();
                    _b.label = 7;
                case 7:
                    _a;
                    _b.label = 8;
                case 8:
                    _i++;
                    return [3 /*break*/, 3];
                case 9: return [2 /*return*/];
            }
        });
    });
}
exports.copyDir = copyDir;
var defaultHashMaker = function (str) {
    return 'b64-' + Buffer.from(str).toString('base64');
};
exports.defaultHashMaker = defaultHashMaker;
var getFilesFromFolder = function (_a) {
    var folder = _a.folder, addOriginalPath = _a.addOriginalPath, ignorePattern = _a.ignorePattern, customHashMaker = _a.customHashMaker;
    var hashMaker = customHashMaker ? customHashMaker : exports.defaultHashMaker;
    var allFiles = (0, glob_1.sync)('**/*', {
        cwd: folder,
        dot: false,
        absolute: true
    })
        .map(function (file) {
        try {
            if (!fs.statSync(file).isFile())
                return;
        }
        catch (err) {
            return;
        }
        var _folder = folder.replace(/\\/gi, '/');
        var key = file.replace(_folder, '').replace(/^\/+/, '');
        return key;
    })
        .filter(function ($) { return !!$; });
    var ensureIgnorePattern = ignorePattern && ignorePattern !== '' ? ignorePattern : (0, exports.defaultDclIgnore)();
    var ig = (0, ignore_1["default"])().add(ensureIgnorePattern);
    var filteredFiles = ig.filter(allFiles);
    return filteredFiles
        .map(function (file) {
        var absolutePath = path.resolve(folder, file);
        try {
            if (!fs.statSync(absolutePath).isFile())
                return;
        }
        catch (err) {
            console.log(err);
            return;
        }
        var absoluteFolder = folder.replace(/\\/gi, '/');
        var relativeFilePathToFolder = file
            .replace(absoluteFolder, '')
            .replace(/^\/+/, '');
        return {
            file: relativeFilePathToFolder.toLowerCase(),
            original_path: addOriginalPath ? absolutePath : undefined,
            hash: hashMaker(absolutePath)
        };
    })
        .filter(function ($) { return !!$; });
};
exports.getFilesFromFolder = getFilesFromFolder;
function entityV3FromFolder(_a) {
    var folder = _a.folder, addOriginalPath = _a.addOriginalPath, ignorePattern = _a.ignorePattern, customHashMaker = _a.customHashMaker;
    var sceneJsonPath = path.resolve(folder, './scene.json');
    var isParcelScene = true;
    var assetJsonPath = path.resolve(folder, './asset.json');
    if (fs.existsSync(assetJsonPath)) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            var assetJson = require(assetJsonPath);
            if (schemas_1.sdk.AssetJson.validate(assetJson) &&
                assetJson.assetType === schemas_1.sdk.ProjectType.PORTABLE_EXPERIENCE) {
                isParcelScene = false;
            }
        }
        catch (err) {
            console.error("Unable to load asset.json properly", err);
        }
    }
    var hashMaker = customHashMaker ? customHashMaker : exports.defaultHashMaker;
    if (fs.existsSync(sceneJsonPath) && isParcelScene) {
        var sceneJson = JSON.parse(fs.readFileSync(sceneJsonPath).toString());
        var _b = sceneJson.scene, base = _b.base, parcels = _b.parcels;
        var pointers_1 = new Set();
        pointers_1.add(base);
        parcels.forEach(function ($) { return pointers_1.add($); });
        var mappedFiles = (0, exports.getFilesFromFolder)({
            folder: folder,
            addOriginalPath: addOriginalPath,
            ignorePattern: ignorePattern,
            customHashMaker: customHashMaker
        });
        return {
            version: 'v3',
            type: 'scene',
            id: hashMaker(folder),
            pointers: Array.from(pointers_1),
            timestamp: Date.now(),
            metadata: sceneJson,
            content: mappedFiles
        };
    }
    return null;
}
exports.entityV3FromFolder = entityV3FromFolder;
function getSceneJson(_a) {
    var baseFolders = _a.baseFolders, pointers = _a.pointers, customHashMaker = _a.customHashMaker;
    var requestedPointers = new Set(pointers);
    var resultEntities = [];
    var allDeployments = baseFolders.map(function (folder) {
        var dclIgnorePath = path.resolve(folder, '.dclignore');
        var ignoreFileContent = '';
        if (fs.existsSync(dclIgnorePath)) {
            ignoreFileContent = fs.readFileSync(path.resolve(folder, '.dclignore'), 'utf-8');
        }
        return entityV3FromFolder({
            folder: folder,
            addOriginalPath: false,
            ignorePattern: ignoreFileContent,
            customHashMaker: customHashMaker
        });
    });
    var _loop_1 = function (pointer) {
        // get deployment by pointer
        var theDeployment = allDeployments.find(function ($) { return $ && $.pointers.includes(pointer); });
        if (theDeployment) {
            // remove all the required pointers from the requestedPointers set
            // to prevent sending duplicated entities
            theDeployment.pointers.forEach(function ($) { return requestedPointers["delete"]($); });
            // add the deployment to the results
            resultEntities.push(theDeployment);
        }
    };
    for (var _i = 0, _b = Array.from(requestedPointers); _i < _b.length; _i++) {
        var pointer = _b[_i];
        _loop_1(pointer);
    }
    return resultEntities;
}
exports.getSceneJson = getSceneJson;
function ensureWriteFile(filePath, data) {
    return __awaiter(this, void 0, void 0, function () {
        var directoryPath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    directoryPath = path.dirname(filePath);
                    if (!!fs.existsSync(directoryPath)) return [3 /*break*/, 2];
                    return [4 /*yield*/, fs.promises.mkdir(directoryPath, { recursive: true })];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [4 /*yield*/, fs.promises.writeFile(filePath, data, 'utf-8')];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.ensureWriteFile = ensureWriteFile;
function ensureCopyFile(fromFilePath, filePath) {
    return __awaiter(this, void 0, void 0, function () {
        var directoryPath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    directoryPath = path.dirname(filePath);
                    if (!!fs.existsSync(directoryPath)) return [3 /*break*/, 2];
                    return [4 /*yield*/, fs.promises.mkdir(directoryPath, { recursive: true })];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [4 /*yield*/, fs.promises.copyFile(fromFilePath, filePath)];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.ensureCopyFile = ensureCopyFile;
var downloadFile = function (url, path, timeout_seg) {
    if (timeout_seg === void 0) { timeout_seg = 15; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var file = fs.createWriteStream(path);
                    var schema = http;
                    if (url.toLowerCase().startsWith('https:')) {
                        schema = https;
                    }
                    var finished = false;
                    var request = schema
                        .get(url, function (response) {
                        response.pipe(file);
                        file.on('finish', function () {
                            file.close();
                            finished = true;
                            resolve(true);
                        });
                    })
                        .on('error', function (err) {
                        fs.unlinkSync(path);
                        finished = true;
                        reject(err);
                    });
                    setTimeout(function () {
                        if (!finished) {
                            request.destroy();
                            reject(new Error("Timeout " + url));
                        }
                    }, timeout_seg * 1000);
                })];
        });
    });
};
exports.downloadFile = downloadFile;
var shaHashMaker = function (str) {
    return crypto.createHash('sha1').update(str).digest('hex');
};
exports.shaHashMaker = shaHashMaker;
var defaultDclIgnore = function () {
    return [
        '.*',
        'package.json',
        'package-lock.json',
        'yarn-lock.json',
        'build.json',
        'export',
        'tsconfig.json',
        'tslint.json',
        'node_modules',
        '*.ts',
        '*.tsx',
        'Dockerfile',
        'dist',
        'README.md',
        '*.blend',
        '*.fbx',
        '*.zip',
        '*.rar'
    ].join('\n');
};
exports.defaultDclIgnore = defaultDclIgnore;
var getDirectories = function (source) {
    if (!fs.existsSync(source))
        return [];
    return fs
        .readdirSync(source, { withFileTypes: true })
        .filter(function (dirent) { return dirent.isDirectory(); })
        .map(function (dirent) { return dirent.name; });
};
exports.getDirectories = getDirectories;
var createStaticRoutes = function (app, route, localFolder, mapFile) {
    app.use(route, function (req, res, next) {
        var options = {
            root: localFolder,
            dotfiles: 'deny',
            maxAge: 1,
            cacheControl: false,
            lastModified: true,
            headers: {
                'x-timestamp': Date.now(),
                'x-sent': true,
                etag: JSON.stringify(Date.now().toString()),
                'cache-control': 'no-cache,private,max-age=1'
            }
        };
        var fileName = mapFile ? mapFile(req.params[0]) : req.params[0];
        res.sendFile(fileName, options, function (err) {
            if (err) {
                next(err);
            }
        });
    });
};
exports.createStaticRoutes = createStaticRoutes;
